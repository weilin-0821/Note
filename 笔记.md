## MySQL

### 1. MySQL 索引

索引分单列索引和组合索引：

- 单列索引，即一个索引只包含单个列，一个表可以有多个单列索引。
- 组合索引，即一个索引包含多个列。

#### 1.1 普通索引

通过使用索引，MySQL 可以直接定位到满足查询条件的数据行，而无需逐行扫描整个表。

##### 1.1.1 创建索引

**CREATE INDEX** 的语法：

```sql
CREATE INDEX index_name
ON table_name (column1 [ASC|DESC], column2 [ASC|DESC], ...);
```

- `CREATE INDEX`: 用于创建普通索引的关键字。
- `index_name`: 指定要创建的索引的名称。索引名称在表中必须是唯一的。
- `table_name`: 指定要在哪个表上创建索引。
- `(column1, column2, ...)`: 指定要索引的表列名。你可以指定一个或多个列作为索引的组合。这些列的数据类型通常是数值、文本或日期。
- `ASC`和`DESC`（可选）: 用于指定索引的排序顺序。默认情况下，索引以升序（ASC）排序。

需要注意的是，如果表中的数据量较大，索引的创建可能会花费一些时间，但一旦创建完成，查询性能将会显著提高。

##### 1.1.2 修改表结构(添加索引)

ALTER TABLE 允许你修改表的结构，包括添加、修改或删除索引。

```sql
ALTER TABLE table_name
ADD INDEX index_name (column1 [ASC|DESC], column2 [ASC|DESC], ...);
```

- `ALTER TABLE`: 用于修改表结构的关键字。
- `table_name`: 指定要修改的表的名称。
- `ADD INDEX`: 添加索引的子句。`ADD INDEX`用于创建普通索引。
- `index_name`: 指定要创建的索引的名称。索引名称在表中必须是唯一的。
- `(column1, column2, ...)`: 指定要索引的表列名。你可以指定一个或多个列作为索引的组合。这些列的数据类型通常是数值、文本或日期。
- `ASC`和`DESC`（可选）: 用于指定索引的排序顺序。默认情况下，索引以升序（ASC）排序。

##### 1.1.3 创建表的时候直接指定

```sql
CREATE TABLE table_name (
  column1 data_type,
  column2 data_type,
  ...,
  INDEX index_name (column1 [ASC|DESC], column2 [ASC|DESC], ...)
);
```

- `CREATE TABLE`: 用于创建新表的关键字。
- `table_name`: 指定要创建的表的名称。
- `(column1 data_type, column2 data_type, ...)`: 定义表的列名和数据类型。你可以指定一个或多个列作为索引的组合。这些列的数据类型通常是数值、文本或日期。
- `INDEX`: 用于创建普通索引的关键字。
- `index_name`: 指定要创建的索引的名称。索引名称在表中必须是唯一的。
- `(column1, column2, ...)`: 指定要索引的表列名。你可以指定一个或多个列作为索引的组合。这些列的数据类型通常是数值、文本或日期。
- `ASC`和`DESC`（可选）: 用于指定索引的排序顺序。默认情况下，索引以升序（ASC）排序。

#### 1.2 删除索引的语法

```sql
DROP INDEX index_name ON table_name;
```

- `DROP INDEX`: 用于删除索引的关键字。
- `index_name`: 指定要删除的索引的名称。
- `ON table_name`: 指定要在哪个表上删除索引。

```sql
ALTER TABLE table_name
DROP INDEX index_name;
```

#### 1.3 唯一索引

在 MySQL 中，你可以使用 **CREATE UNIQUE INDEX** 语句来创建唯一索引。

唯一索引确保索引中的值是唯一的，不允许有重复值。

##### 1.3.1 创建索引

```sql
CREATE UNIQUE INDEX index_name
ON table_name (column1 [ASC|DESC], column2 [ASC|DESC], ...);
```

- `CREATE UNIQUE INDEX`: 用于创建唯一索引的关键字组合。
- `index_name`: 指定要创建的唯一索引的名称。索引名称在表中必须是唯一的。
- `table_name`: 指定要在哪个表上创建唯一索引。
- `(column1, column2, ...)`: 指定要索引的表列名。你可以指定一个或多个列作为索引的组合。这些列的数据类型通常是数值、文本或日期。

- `ASC`和`DESC`（可选）: 用于指定索引的排序顺序。默认情况下，索引以升序（ASC）排序。

##### 1.3.2 修改表结构添加索引

```sql
ALTER table table_name 
ADD CONSTRAINT unique_constraint_name UNIQUE (column1, column2, ...);
```

- `ALTER TABLE`: 用于修改表结构的关键字。
- `table_name`: 指定要修改的表的名称。
- `ADD CONSTRAINT`: 这是用于添加约束（包括唯一索引）的关键字。
- `unique_constraint_name `: 指定要创建的唯一索引的名称，约束名称在表中必须是唯一的。
- `UNIQUE (column1, column2, ...)`: 指定要索引的表列名。你可以指定一个或多个列作为索引的组合。这些列的数据类型通常是数值、文本或日期。

##### 1.3.3 创建表的时候直接指定

```sql
CREATE TABLE table_name (
  column1 data_type,
  column2 data_type,
  ...,
  CONSTRAINT index_name UNIQUE (column1 [ASC|DESC], column2 [ASC|DESC], ...)
);
```

- `CREATE TABLE`: 用于创建新表的关键字。
- `table_name`: 指定要创建的表的名称。
- `(column1 data_type, column2 data_type, ...)`: 定义表的列名和数据类型。你可以指定一个或多个列作为索引的组合。这些列的数据类型通常是数值、文本或日期。
- `CONSTRAINT`: 用于添加约束的关键字。
- `index_name`: 指定要创建的唯一索引的名称。约束名称在表中必须是唯一的。
- `UNIQUE (column1, column2, ...)`: 指定要索引的表列名。
- `ASC`和`DESC`（可选）: 用于指定索引的排序顺序。默认情况下，索引以升序（ASC）排序。

#### 1.4 使用ALTER 命令添加和删除索引

有四种方式来添加数据表的索引：

- **ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):**该语句添加一个主键，主键列中的值必须唯一，主键的列的列表，可以是一个或多个列，不能包含 NULL 值。 
- **ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):** 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。
- **ALTER TABLE tbl_name ADD INDEX index_name (column_list):** 添加普通索引，索引值可出现多次。
- **ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):**该语句指定了索引为 FULLTEXT ，用于全文索引。

#### 1.5 显示索引信息

你可以使用 **SHOW INDEX** 命令来列出表中的相关的索引信息。

可以通过添加 **\G** 来格式化输出信息。

```cmd
mysql> SHOW INDEX FROM table_name\G
........
```

- `SHOW INDEX`: 用于显示索引信息的关键字。
- `FROM table_name`: 指定要查看索引信息的表的名称。
- `\G`: 格式化输出信息。

执行上述命令后，将会显示指定表中所有索引的详细信息，包括索引名称（Key_name）、索引列（Column_name）、是否是唯一索引（Non_unique）、排序方式（Collation）、索引的基数（Cardinality）等.

### 2. MySQL 临时表

临时表只在当前连接可见，当关闭连接时，MySQL 会自动删除表并释放所有空间。

在 MySQL 中，临时表是一种在当前会话中存在的表，它在会话结束时会自动被销毁。

MySQL 临时表只在当前连接可见，如果你使用PHP脚本来创建 MySQL 临时表，那每当 PHP 脚本执行完成后，该临时表也会自动销毁。

如果你使用了其他 MySQL 客户端程序连接 MySQL 数据库服务器来创建临时表，那么只有在关闭客户端程序时才会销毁临时表，当然你也可以手动销毁。

#### 2.1 创建临时表

```sql
CREATE TEMPORARY TABLE temp_table_name (
  column1 datatype,
  column2 datatype,
  ...
);
```

或者简写为：

```sql
CREATE TEMPORARY TABLE temp_table_name AS
SELECT column1, column2, ...
FROM source_table
WHERE condition;
```

临时表对于需要在某个会话中存储中间结果集或进行复杂查询时非常有用。

临时表的作用范围仅限于创建它的会话。其他会话无法直接访问或引用该临时表。在多个会话之间共享数据时，可以考虑使用普通表而不是临时表。

请注意，临时表在会话结束时会被自动删除，但也可以使用 DROP TEMPORARY TABLE 明确删除它，这样可以更早地释放资源。



### 3. 个人总结

#### 3.1 sql 四大排名函数

##### 3.1.1 ROW_NUMBER()

定义：ROW_NUMBER()函数作用就是将select查询到的数据进行排序，每一条数据加一个序号

```sql
select 
    row_number() over(order by studentScore sesc) number,
    *
from 
    student
```

说明：

​	over（）：排序范围；

​	number ：别名；

##### 3.1.2 RANK()

定义：RANK()函数，顾名思义排名函数，可以对某一个字段进行排名

**与ROW_NUMBER()的区别:**

​	ROW_NUMBER()是排序，当存在相同成绩的学生时，ROW_NUMBER()会依次进行排序，他们序号不相同;

​	rank()值相同时，排序相同

##### 3.1.3 DENSE_RANK()

定义：和RANK()功能相似

**与DENSE_RANK()的区别:**

​	rank()排序跳跃，如，1，1，3，4，5，5，5，8

​	DENSE_RANK()排序不跳跃，如1，1，2

##### 3.1.4 NTILE()

​	NTILE()函数是将有序分区中的行分发到指定数目的组中，各个组有编号，编号从1开始，就像我们说的’分区’一样 ，分为几个区，一个区会有多少个。

#### 3.2 order by 关键字

ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。

ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。

**SQL ORDER BY 语法**

```sql
SELECT column1, column2, ...
FROM table_name
ORDER BY column1, column2, ... ASC|DESC;
```

- **column1, column2, ...**：要排序的字段名称，可以为多个字段。
- **ASC**：表示按升序排序。
- **DESC**：表示按降序排序，如1，2，3，4

#### 3.3 substr函数

##### 3.3.1 SUBSTR(str,pos,len): 从pos开始的位置，截取len个字符

```sql
substr(string ,1,3) ：取string左边第1位置起，3字长的字符串。
所以结果为： str
substr(string, -1,3)：取string右边第1位置起，3字长的字符串。显然右边第一位置起往右不够3字长。结果只能是： g
substr(string, -3,3)：取string右边第3位置起，3字长的字符串。
结果为: ing
```

##### 3.3.2 SUBSTR(str,pos): pos开始的位置，一直截取到最后

```sql
substr(string ,4) : 从右第4位置截取到最后
结果是： ing
```

#### 3.5 CAST函数

CAST函数用于将某种数据类型的表达式显式转换为另一种数据类型。CAST()函数的参数是一个表达式，它包括用AS关键字分隔的源值和目标数据类型。

```sql
cast (expression AS data_type)
```

字段类型要使用char（255）

#### 3.6 union all

在 SQL 中，UNION ALL 操作用于结合两个或更多 SELECT 语句的结果集，包括所有匹配的行，甚至包括重复的行。这与 UNION 不同，因为 UNION 会自动删除重复的行。

满足条件：

1. 两个select查询的列的数量必须相同。
2. 每个列的数据类型需要相似。

```sql
SELECT id, name FROM table1  
UNION ALL  
SELECT id, name FROM table2;
```

#### 3.7 EXISTS / NOT  EXISTS运算符

EXISTS 运算符用于判断查询子句是否有记录，如果有一条或多条记录存在返回 True，否则返回 False。

**SQL EXISTS 语法**

```sql
SELECT column_name(s)
FROM table_name
WHERE EXISTS
(SELECT column_name FROM table_name WHERE condition);
```

**例子**

```sql
and not exists(
    select 1
    from crm_base.tmp_gptg_ls_:NOW_DATE t1
    where t.client_id = t1.client_id
  )
```

**`select 1` 的作用**：

- 在子查询中，你可以选择任何列或者常数。例如，`select 1` 是常见的做法，因为它简单且执行效率高。
- `select 1` 表示查询任何满足条件的行，查询的内容本身不会影响 `EXISTS` 的逻辑。我们只关心是否有符合条件的行存在。
- 例如，`select *` 或 `select 1` 的效果是一样的，关键在于是否有行返回。

#### 3.8 case

它可以根据不同的条件返回不同的值。它的作用类似于编程语言中的 `if-else` 语句。`CASE` 语句常用于 `SELECT`、`UPDATE`、`DELETE` 等 SQL 操作中。

##### 3.8.1 简单 CASE 表达式

在简单 `CASE` 表达式中，检查的是某个字段或值是否等于指定的常量值，根据这个值来返回不同的结果。

```sql
SELECT 
    CASE column_name
        WHEN value1 THEN result1
        WHEN value2 THEN result2
        ELSE default_result
    END AS alias_name
FROM table_name;
```

- `column_name` 是要检查的字段或值。
- `value1`, `value2` 是要与 `column_name` 比较的常量。
- `result1`, `result2` 是与这些常量匹配时返回的结果。
- `ELSE default_result` 是可选的，如果没有任何 `WHEN` 条件匹配，则返回的默认值。

#### 3.9 运算符<>和<=>

在MySQL中!= 和 <> 的功能一致，在sql92规范中建议是：!=，新的规范中建议为: <>

 is 专门用来判断是否为 NULL，而 = 则是用来判断非NULL以外的所有数据类型使用。而 <=> 则是前两者合起来。

### 4. 变量

#### 4.1 用户变量

用户变量是在 SQL 会话中使用的变量，它们不需要事先声明，可以直接在查询中赋值和使用。用户变量通常以 `@` 符号开头。

```sql
#语法
SET @variable_name = value;
#赋值： 使用 SET 语句为变量赋值，或者在 SELECT 语句中直接赋值
SET @my_var = 100;
SELECT @my_var;
#在查询中使用： 用户变量在同一会话内可以被多次使用，在 SELECT 语句中赋值，并可以直接引用
SET @a = 10;
SET @b = 20;
SELECT @a + @b AS sum;
#通过查询赋值： 用户变量可以通过查询结果赋值，例如将查询结果直接赋给变量。
SELECT COUNT(*) INTO @row_count FROM employees;
```

#### 4.2 局部变量

局部变量是在存储过程（`stored procedure`）或函数（`function`）中使用的变量。它们在函数或存储过程中定义，作用范围仅限于该存储过程或函数。

```sql
#语法
DECLARE variable_name datatype;
```

```sql
#示例
DELIMITER $$

CREATE PROCEDURE example_procedure()
BEGIN
    DECLARE my_variable INT;
    SET my_variable = 100;
    SELECT my_variable;
END$$

DELIMITER ;
```

在这个例子中，`my_variable` 是存储过程中的局部变量，只能在 `example_procedure` 存储过程内部访问。

#### 特点：

- 局部变量在存储过程或函数执行时存在，执行结束后它们会被销毁。
- 需要在存储过程或函数的开头使用 `DECLARE` 语句进行声明。

#### 4.3 系统变量

系统变量是 MySQL 的预定义变量，用于控制 MySQL 的行为和配置参数。系统变量有两种类型：

- **全局系统变量**：影响整个 MySQL 实例的行为，适用于所有连接。
- **会话系统变量**：只影响当前连接的会话。

获取和设置系统变量：

1. **查看系统变量**： 可以使用 `SHOW VARIABLES` 查看系统变量的值。

   ```sql
   SHOW VARIABLES LIKE 'autocommit';
   ```

2. **设置系统变量**： 使用 `SET` 语句来设置系统变量。

   设置会话变量：

   ```sql
   SET autocommit = 0;  -- 关闭当前会话的自动提交
   ```

   设置全局变量（需要管理员权限）：

   ```sql
   SET GLOBAL max_connections = 200;  -- 设置全局最大连接数
   ```

#### 4.4 常见的系统变量：

- `max_connections`：最大连接数。
- `autocommit`：是否自动提交事务。
- `wait_timeout`：等待连接的超时时间。
- `innodb_buffer_pool_size`：InnoDB 缓冲池的大小。

**特点：**

- 系统变量可用于调整 MySQL 的配置和优化，影响 MySQL 服务的行为。
- 会话级变量在当前会话结束后会被销毁，而全局变量的值会影响到整个 MySQL 实例，直到它们被修改。



## java

### 1. 集合

#### 1.1 List,Set,Queue,Map四者的区别

- `List`: 顺序存储，可重复。
- `Set`: 不可重复。
- `Queue`: 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。
- `Map`: 使用键值对（key-value）存储，Key无序不可重复。value无序可重复。



#### 1.2 集合框架底层数据结构总结

List

- `ArrayList`：`Object[]` 数组，适用于频繁的查找工作，**线程不安全**。
- `Vector`：`Object[]` 数组，**线程安全**。
- `LinkedList`：双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)。

Set

- `HashSet`(无序，唯一): 基于 `HashMap` 实现的，底层采用 `HashMap` 来保存元素。
- `LinkedHashSet`: `LinkedHashSet` 是 `HashSet` 的子类，并且其内部是通过 `LinkedHashMap` 来实现的。
- `TreeSet`(有序，唯一): 红黑树(自平衡的排序二叉树)。

Queue

- `PriorityQueue`: `Object[]` 数组来实现小顶堆。
- `DelayQueue`:`PriorityQueue`。
- `ArrayDeque`: 可扩容动态双向数组。

Map

- `HashMap`：

  - **JDK1.8 之前**： `HashMap` 由数组+链表组成的，数组是 `HashMap` 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。

  - **JDK1.8 以后**：在解决哈希冲突时有了较大的变化，当链表长度大于阈值（**默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。**

    **总结：**

    数组<8: 链表

    8<数组<64：数组

    64<数组：红黑树

- `LinkedHashMap`：`LinkedHashMap` 继承自 `HashMap`，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，`LinkedHashMap` 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。

- `Hashtable`：数组+链表组成的，数组是 `Hashtable` 的主体，链表则是主要为了解决哈希冲突而存在的。

- `TreeMap`：红黑树（自平衡的排序二叉树）。

## Shell

### 1. Shell脚本（Bash_Bourne Again Shell）

​	打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好

#### 1.1 第一个shell脚本

```shell
#!/bin/bash
echo "Hello World !"
```

​	**#!** 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。

​	echo 命令用于向窗口输出文本。

#### 1.2 运行Shell脚本的两种方法

##### 1.2.1 作为可执行程序

将上面的代码保存为 test.sh，并 cd 到相应目录：

```sh
chmod +x ./test.sh  #使脚本具有执行权限
./test.sh  #执行脚本
```

注意，一定要写成 **./test.sh**，而不是 **test.sh**，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。

##### 1.2.2  **作为解释器参数**

这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：

/bin/sh test.sh
/bin/php test.php

### 2. Shell变量

#### 2.1 Shell变量定义

定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如：

```shell
your_name="runoob"
```

**注意：**

- **只包含字母、数字和下划线：** 变量名可以包含字母（大小写敏感）、数字和下划线 **_**，不能包含其他特殊字符。
- **不能以数字开头：** 变量名不能以数字开头，但可以包含数字。
- **避免使用 Shell 关键字：** 不要使用Shell的关键字（例如 if、then、else、fi、for、while 等）作为变量名，以免引起混淆。
- **使用大写字母表示常量：** 习惯上，常量的变量名通常使用大写字母，例如 **PI=3.14**。
- **避免使用特殊符号：** 尽量避免在变量名中使用特殊符号，因为它们可能与 Shell 的语法产生冲突。
- **避免使用空格：** 变量名中不应该包含空格，因为空格通常用于分隔命令和参数。

有效的 Shell 变量名示例如下：

```shell
RUNOOB="www.runoob.com"
LD_LIBRARY_PATH="/bin/"
_var="123"
var2="abc"
```

除了显式地直接赋值，还可以用语句给变量赋值，如：

```shell
for file in `ls /etc`
或
for file in $(ls /etc)
```

以上语句将 /etc 下目录的文件名循环出来。

#### 2.2 使用变量

使用一个定义过的变量，只要在变量名前面加美元符号即可，如：

```shell
your_name="qinjx"
echo $your_name
echo ${your_name}
```

变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：

```shell
for skill in Ada Coffe Action Java; do
    echo "I am good at ${skill}Script"
done
```

​	如果不给skill变量加花括号，写成echo "I am good at $skillScript"，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。

**推荐给所有变量加上花括号，这是个好的编程习惯。**

已定义的变量，可以被重新定义，如：

```shell
your_name="tom"
echo $your_name
your_name="alibaba"
echo $your_name
```

**使用变量的时候才加美元符（$）**

#### 2.3 只读变量

使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。

下面的例子尝试更改只读变量，结果报错：

```shell
#!/bin/bash
myUrl="https://www.google.com"
readonly myUrl
myUrl="https://www.runoob.com"
```

运行结果：

```cmd
/bin/sh: NAME: This variable is read only.
```

#### 2.4 删除变量

使用 unset 命令可以删除变量。语法：

```shell
unset variable_name
```

变量被删除后不能再次使用。unset 命令不能删除只读变量。

```shell
#!/bin/sh

myUrl="https://www.runoob.com"
unset myUrl
echo $myUrl
```

以上实例执行将没有任何输出。

#### 2.5 变量类型

Shell 支持不同类型的变量，其中一些主要的类型包括：

##### 2.5.1 **字符串变量：**

 **在 Shell中，变量通常被视为字符串。**

你可以使用单引号 **'** 或双引号 **"** 来定义字符串，例如：

```shell
my_string='Hello, World!'

或者

my_string="Hello, World!"
```

##### 2.5.2 **整数变量**： 

**在一些Shell中，你可以使用 declare 或 typeset 命令来声明整数变量。**

这样的变量只包含整数值，例如：

```shell
declare -i my_integer=42
```

这样的声明告诉 Shell 将 my_integer 视为整数，如果尝试将非整数值赋给它，Shell会尝试将其转换为整数。

##### 2.5.3 **数组变量：**

**Shell 也支持数组，允许你在一个变量中存储多个值。**

数组可以是整数索引数组或关联数组，以下是一个简单的整数索引数组的例子：

```shell
my_array=(1 2 3 4 5)
```

或者关联数组：

```shell
declare -A associative_array
associative_array["name"]="John"
associative_array["age"]=30
```

##### 2.5.4 **环境变量：**

这些是由操作系统或用户设置的特殊变量，用于配置 Shell 的行为和影响其执行环境。

```shell
echo $PATH
```

##### 2.5.5 **特殊变量：**

**有一些特殊变量在 Shell 中具有特殊含义，例如 $0 表示脚本的名称，$1, $2, 等表示脚本的参数。**

**$#**表示传递给脚本的参数数量，**$?** 表示上一个命令的退出状态等。

#### 2.6 Shell字符串

字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。

##### 2.6.1 单引号

```shell
str='this is a string'
```

单引号字符串的限制：

- 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；
- 单引号字符串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

##### 2.6.2 双引号

```shell
your_name="runoob"
str="Hello, I know you are \"$your_name\"! \n"
echo -e $str
```

双引号的优点：

- 双引号里可以有变量
- 双引号里可以出现转义字符

##### 2.6.3 拼接字符串

```shell
your_name="runoob"
# 使用双引号拼接
greeting="hello, "$your_name" !"
greeting_1="hello, ${your_name} !"
echo $greeting  $greeting_1

# 使用单引号拼接
greeting_2='hello, '$your_name' !'
greeting_3='hello, ${your_name} !'
echo $greeting_2  $greeting_3
```

输出结果：

```cmd
hello, runoob ! hello, runoob !
hello, runoob ! hello, ${your_name} !
```

##### 2.6.4 获取字符串长度

```shell
string="abcd"
echo ${#string}   # 输出 4
```

变量为字符串时，**${#string}** 等价于 **${#string[0]}**:

```shell
string="abcd"
echo ${#string[0]}   # 输出 4
```

##### 2.6.5 提取子字符串

以下实例从字符串第 **2** 个字符开始截取 **4** 个字符：

```shell
string="runoob is a great site"
echo ${string:1:4} # 输出 unoo
```

**注意**：第一个字符的索引值为 **0**。

##### 2.6.6 查找子字符串

查找字符 **i** 或 **o** 的位置(哪个字母先出现就计算哪个)：

```shell
string="runoob is a great site"
echo `expr index "$string" io`  # 输出 4
```

**注意：** 以上脚本中 **`** 是反引号，而不是单引号 **'**，不要看错了哦。

#### 2.7 Shell 数组

bash支持一维数组（不支持多维数组），并且没有限定数组的大小。

类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。

##### 2.7.1 定义数组

在 Shell 中，用括号来表示数组，数组元素用"空格"符号分割开。定义数组的一般形式为：

```shell
数组名=(值1 值2 ... 值n)
```

例如：

```shell
array_name=(value0 value1 value2 value3)
```

或者

```shell
array_name=(
value0
value1
value2
value3
)
```

可以不使用连续的下标，而且下标的范围没有限制。

##### 2.7.2 读取数组

读取数组元素值的一般格式是：

```shell
${数组名[下标]}
```

例如：

```shell
valuen=${array_name[n]}
```

使用 **@** 符号可以获取数组中的所有元素，例如：

```shell
echo ${array_name[@]}
```

##### 2.7.3 获取数组的长度

获取数组长度的方法与获取字符串长度的方法相同，例如：

```shell
# 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
length=${#array_name[n]}
```

#### 2.8 Shell 注释

以 **#** 开头的行就是注释，会被解释器忽略。

通过每一行加一个 **#** 号设置多行注释，像这样：

```shell
#--------------------------------------------
# 这是一个注释
# author：菜鸟教程
# site：www.runoob.com
# slogan：学的不仅是技术，更是梦想！
#--------------------------------------------
##### 用户配置区 开始 #####
#
#
# 这里可以添加脚本描述信息
# 
#
##### 用户配置区 结束  #####
```

​	如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？

​	每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。

##### 2.8.1 多行注释

**使用 Here 文档**

多行注释还可以使用以下格式：

```shell
:<<EOF
注释内容...
注释内容...
注释内容...
EOF
```

以上例子中，**:** 是一个空命令，用于执行后面的 Here 文档，**<<'EOF'** 表示开启 Here 文档，COMMENT 是 Here 文档的标识符，在这两个标识符之间的内容都会被视为注释，不会被执行。

EOF 也可以使用其他符号:

```shell
: <<'COMMENT'
这是注释的部分。
可以有多行内容。
COMMENT

:<<'
注释内容...
注释内容...
注释内容...
'

:<<!
注释内容...
注释内容...
注释内容...
!
```

**直接使用 : 号**

我们也可以使用了冒号 **:** 命令，并用单引号 **'** 将多行内容括起来。由于冒号是一个空命令，这些内容不会被执行。

格式为：**: + 空格 + 单引号**。

```shell
: '
这是注释的部分。
可以有多行内容。
'
```

### 3. Shell 传递参数

​	我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为 **$n**，**n** 代表一个数字，**1** 为执行脚本的第一个参数，**2** 为执行脚本的第二个参数。

​	例如可以使用 **$1、$2** 等来引用传递给脚本的参数，其中 **$1** 表示第一个参数，**$2** 表示第二个参数，依此类推。

实例

以下实例我们向脚本传递三个参数，并分别输出，其中 **$0** 为执行的文件名（包含文件路径）：

```shell
#!/bin/bash

echo "Shell 传递参数实例！";
echo "执行的文件名：$0";
echo "第一个参数为：$1";
echo "第二个参数为：$2";
echo "第三个参数为：$3";
```

为脚本设置可执行权限，并执行脚本，输出结果如下所示：

```shell
$ chmod +x test.sh 
$ ./test.sh 1 2 3
Shell 传递参数实例！
执行的文件名：./test.sh
第一个参数为：1
第二个参数为：2
第三个参数为：3
```

另外，还有几个特殊字符用来处理参数：

| 参数处理 | **说明**                                                     |
| -------- | ------------------------------------------------------------ |
| $#       | 传递到脚本的参数个数                                         |
| $*       | 以一个单字符串显示所有向脚本传递的参数。<br/>如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。 |
| $$       | 脚本运行的当前进程ID号                                       |
| $!       | 后台运行的最后一个进程的ID号                                 |
| $@       | 与$*相同，但是使用时加引号，并在引号中返回每个参数。 如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。 |
| $-       | 显示Shell使用的当前选项，与[set命令](https://www.runoob.com/linux/linux-comm-set.html)功能相同。 |
| $?       | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |

```shell
#!/bin/bash

echo "Shell 传递参数实例！";
echo "第一个参数为：$1";

echo "参数个数为：$#";
echo "传递的参数作为一个字符串显示：$*";
```

执行脚本，输出结果如下所示：

```shell
$ chmod +x test.sh 
$ ./test.sh 1 2 3
Shell 传递参数实例！
第一个参数为：1
参数个数为：3
传递的参数作为一个字符串显示：1 2 3
```

$* 与 $@ 区别：

- 相同点：都是引用所有参数。
- 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，则 " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）。

```shell
#!/bin/bash

echo "-- \$* 演示 ---"
for i in "$*"; do
    echo $i
done

echo "-- \$@ 演示 ---"
for i in "$@"; do
    echo $i
done
```

执行脚本，输出结果如下所示：

```shell
$ chmod +x test.sh 
$ ./test.sh 1 2 3
-- $* 演示 ---
1 2 3
-- $@ 演示 ---
1
2
3
```

### 4. Shell 数组

​	数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。

与大部分编程语言类似，数组元素的下标由 0 开始。

Shell 数组用括号来表示，元素用"空格"符号分割开，语法格式如下：

```shell
array_name=(value1 value2 ... valuen)
```

**实例**

创建一个简单的数组 **my_array**：

```shell
#!/bin/bash

my_array=(A B "C" D)
```

我们也可以使用数字下标来定义数组:

```shell
array_name[0]=value0
array_name[1]=value1
array_name[2]=value2
```

#### 4.1 读取数组

读取数组元素值的一般格式是：

```shell
${array_name[index]}
```

以下实例通过数字索引读取数组元素：

#!/bin/bash

my_array=(A B "C" D)

echo "第一个元素为: ${my_array[0]}"
echo "第二个元素为: ${my_array[1]}"
echo "第三个元素为: ${my_array[2]}"
echo "第四个元素为: ${my_array[3]}"

执行脚本，输出结果如下所示：

```shell
$ chmod +x test.sh 
$ ./test.sh
第一个元素为: A
第二个元素为: B
第三个元素为: C
第四个元素为: D
```

#### 4.2 关联数组

Bash 支持关联数组，可以使用任意的字符串、或者整数作为下标来访问数组元素。

关联数组使用 **[declare](https://www.runoob.com/linux/linux-comm-declare.html)** 命令来声明，语法格式如下：

```shell
declare -A array_name
```

**A** 选项就是用于声明一个关联数组。

关联数组的键是唯一的。

以下实例我们创建一个关联数组 **site**，并创建不同的键值：

```shell
declare -A site=(["google"]="www.google.com" ["runoob"]="www.runoob.com" ["taobao"]="www.taobao.com")
```

我们也可以先声明一个关联数组，然后再设置键和值：

```shell
[declare -A site
site["google"]="www.google.com"
site["runoob"]="www.runoob.com"
site["taobao"]="www.taobao.com"]()
```

也可以在定义的同时赋值：

访问关联数组元素可以使用指定的键，格式如下：

```shell
array_name["index"]
```

以下实例我们通过键来访问关联数组的元素：

```shell
declare -A site
site["google"]="www.google.com"
site["runoob"]="www.runoob.com"
site["taobao"]="www.taobao.com"

echo ${site["runoob"]}
```

执行脚本，输出结果如下所示：

```shell
www.runoob.com
```

#### 4.3 获取数组中的所有元素

使用 **@** 或 ***** 可以获取数组中的所有元素，例如：

```shell
#!/bin/bash

my_array[0]=A
my_array[1]=B
my_array[2]=C
my_array[3]=D

echo "数组的元素为: ${my_array[*]}"
echo "数组的元素为: ${my_array[@]}"
```

执行脚本，输出结果如下所示：

```shell
$ chmod +x test.sh 
$ ./test.sh
数组的元素为: A B C D
数组的元素为: A B C D
```

```shell
declare -A site
site["google"]="www.google.com"
site["runoob"]="www.runoob.com"
site["taobao"]="www.taobao.com"

echo "数组的元素为: ${site[*]}"
echo "数组的元素为: ${site[@]}"
```

执行脚本，输出结果如下所示：

```shell
$ chmod +x test.sh 
$ ./test.sh
数组的元素为: www.google.com www.runoob.com www.taobao.com
数组的元素为: www.google.com www.runoob.com www.taobao.com
```

在数组前加一个感叹号 **!** 可以获取数组的所有键，例如：

```shell
declare -A site
site["google"]="www.google.com"
site["runoob"]="www.runoob.com"
site["taobao"]="www.taobao.com"

echo "数组的键为: ${!site[*]}"
echo "数组的键为: ${!site[@]}"
```

执行脚本，输出结果如下所示：

```shell
数组的键为: google runoob taobao
数组的键为: google runoob taobao
```

#### 4.4 获取数组的长度

获取数组长度的方法与获取字符串长度的方法相同，例如：

```shell
#!/bin/bash

my_array[0]=A
my_array[1]=B
my_array[2]=C
my_array[3]=D

echo "数组元素个数为: ${#my_array[*]}"
echo "数组元素个数为: ${#my_array[@]}"
```

执行脚本，输出结果如下所示：

```shell
$ chmod +x test.sh 
$ ./test.sh
数组元素个数为: 4
数组元素个数为: 4
```

### 5. Shell 基本运算符

Shell 和其他编程语言一样，支持多种运算符，包括：

- 算数运算符
- 关系运算符
- 布尔运算符
- 字符串运算符
- 文件测试运算符

原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。

expr 是一款表达式计算工具，使用它能完成表达式的求值操作。

**例如，两个数相加(注意使用的是反引号` 而不是单引号 ')：**

```shell
#!/bin/bash

val=`expr 2 + 2`
echo "两数之和为 : $val"
```

执行脚本，输出结果如下所示：

```shell
两数之和为 : 4
```

两点注意：

- 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。
- 完整的表达式要被 **` `** 包含，注意这个字符不是常用的单引号，在 Esc 键下边。

#### 5.1 算术运算符

下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                          | 举例                          |
| :----- | :-------------------------------------------- | :---------------------------- |
| +      | 加法                                          | `expr $a + $b` 结果为 30。    |
| -      | 减法                                          | `expr $a - $b` 结果为 -10。   |
| *      | 乘法                                          | `expr $a \* $b` 结果为  200。 |
| /      | 除法                                          | `expr $b / $a` 结果为 2。     |
| %      | 取余                                          | `expr $b % $a` 结果为 0。     |
| =      | 赋值                                          | a=$b 把变量 b 的值赋给 a。    |
| ==     | 相等。用于比较两个数字，相同则返回 true。     | [ $a == $b ] 返回 false。     |
| !=     | 不相等。用于比较两个数字，不相同则返回 true。 | [ $a != $b ] 返回 true。      |

**注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。**

实例

算术运算符实例如下：

```shell
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

a=10
b=20

val=`expr $a + $b`
echo "a + b : $val"

val=`expr $a - $b`
echo "a - b : $val"

val=`expr $a \* $b`
echo "a * b : $val"

val=`expr $b / $a`
echo "b / a : $val"

val=`expr $b % $a`
echo "b % a : $val"

if [ $a == $b ]
then
   echo "a 等于 b"
fi
if [ $a != $b ]
then
   echo "a 不等于 b"
fi
```

执行脚本，输出结果如下所示：

```shell
a + b : 30
a - b : -10
a * b : 200
b / a : 2
b % a : 0
a 不等于 b
```

```cmd
注意：

乘号(*)前边必须加反斜杠(\)才能实现乘法运算；
if...then...fi 是条件语句，后续将会讲解。
在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 "*" 不需要转义符号 "\" 。
```

#### 5.2 关系运算符

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。

下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                                  | 举例                       |
| :----- | :---------------------------------------------------- | :------------------------- |
| -eq    | 检测两个数是否相等，相等返回 true。                   | [ $a -eq $b ] 返回 false。 |
| -ne    | 检测两个数是否不相等，不相等返回 true。               | [ $a -ne $b ] 返回 true。  |
| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | [ $a -gt $b ] 返回 false。 |
| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | [ $a -lt $b ] 返回 true。  |
| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | [ $a -ge $b ] 返回 false。 |
| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | [ $a -le $b ] 返回 true。  |

实例

关系运算符实例如下：

```shell
#!/bin/bash

a=10
b=20

if [ $a -eq $b ]
then
   echo "$a -eq $b : a 等于 b"
else
   echo "$a -eq $b: a 不等于 b"
fi
if [ $a -ne $b ]
then
   echo "$a -ne $b: a 不等于 b"
else
   echo "$a -ne $b : a 等于 b"
fi
if [ $a -gt $b ]
then
   echo "$a -gt $b: a 大于 b"
else
   echo "$a -gt $b: a 不大于 b"
fi
if [ $a -lt $b ]
then
   echo "$a -lt $b: a 小于 b"
else
   echo "$a -lt $b: a 不小于 b"
fi
if [ $a -ge $b ]
then
   echo "$a -ge $b: a 大于或等于 b"
else
   echo "$a -ge $b: a 小于 b"
fi
if [ $a -le $b ]
then
   echo "$a -le $b: a 小于或等于 b"
else
   echo "$a -le $b: a 大于 b"
fi
```

执行脚本，输出结果如下所示：

```shell
10 -eq 20: a 不等于 b
10 -ne 20: a 不等于 b
10 -gt 20: a 不大于 b
10 -lt 20: a 小于 b
10 -ge 20: a 小于 b
10 -le 20: a 小于或等于 b
```

#### 5.3 布尔运算符

下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                                | 举例                                     |
| :----- | :-------------------------------------------------- | :--------------------------------------- |
| !      | 非运算，表达式为 true 则返回 false，否则返回 true。 | [ ! false ] 返回 true。                  |
| -o     | 或运算，有一个表达式为 true 则返回 true。           | [ $a -lt 20 -o $b -gt 100 ] 返回 true。  |
| -a     | 与运算，两个表达式都为 true 才返回 true。           | [ $a -lt 20 -a $b -gt 100 ] 返回 false。 |

实例

布尔运算符实例如下：

```shell
#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

a=10
b=20

if [ $a != $b ]
then
   echo "$a != $b : a 不等于 b"
else
   echo "$a == $b: a 等于 b"
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
   echo "$a 小于 100 且 $b 大于 15 : 返回 true"
else
   echo "$a 小于 100 且 $b 大于 15 : 返回 false"
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
   echo "$a 小于 100 或 $b 大于 100 : 返回 true"
else
   echo "$a 小于 100 或 $b 大于 100 : 返回 false"
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
   echo "$a 小于 5 或 $b 大于 100 : 返回 true"
else
   echo "$a 小于 5 或 $b 大于 100 : 返回 false"
fi
```

执行脚本，输出结果如下所示：

```shell
10 != 20 : a 不等于 b
10 小于 100 且 20 大于 15 : 返回 true
10 小于 100 或 20 大于 100 : 返回 true
10 小于 5 或 20 大于 100 : 返回 false
```

#### 5.4 逻辑运算符

以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:

| 运算符 | 说明       | 举例                                       |
| :----- | :--------- | :----------------------------------------- |
| &&     | 逻辑的 AND | [[ $a -lt 100 && $b -gt 100 ]] 返回 false  |
| \|\|   | 逻辑的 OR  | [[ $a -lt 100 \|\| $b -gt 100 ]] 返回 true |

实例

```shell
逻辑运算符实例如下：

#!/bin/bash

a=10
b=20

if [[ $a -lt 100 && $b -gt 100 ]]
then
   echo "返回 true"
else
   echo "返回 false"
fi

if [[ $a -lt 100 || $b -gt 100 ]]
then
   echo "返回 true"
else
   echo "返回 false"
fi
```

执行脚本，输出结果如下所示：

```shell
返回 false
返回 true
```

#### 5.5 字符串运算符

下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：

| 运算符 | 说明                                         | 举例                     |
| :----- | :------------------------------------------- | :----------------------- |
| =      | 检测两个字符串是否相等，相等返回 true。      | [ $a = $b ] 返回 false。 |
| !=     | 检测两个字符串是否不相等，不相等返回 true。  | [ $a != $b ] 返回 true。 |
| -z     | 检测字符串长度是否为0，为0返回 true。        | [ -z $a ] 返回 false。   |
| -n     | 检测字符串长度是否不为 0，不为 0 返回 true。 | [ -n "$a" ] 返回 true。  |
| $      | 检测字符串是否不为空，不为空返回 true。      | [ $a ] 返回 true。       |

实例

字符串运算符实例如下：

```shell
#!/bin/bash


a="abc"
b="efg"

if [ $a = $b ]
then
   echo "$a = $b : a 等于 b"
else
   echo "$a = $b: a 不等于 b"
fi
if [ $a != $b ]
then
   echo "$a != $b : a 不等于 b"
else
   echo "$a != $b: a 等于 b"
fi
if [ -z $a ]
then
   echo "-z $a : 字符串长度为 0"
else
   echo "-z $a : 字符串长度不为 0"
fi
if [ -n "$a" ]
then
   echo "-n $a : 字符串长度不为 0"
else
   echo "-n $a : 字符串长度为 0"
fi
if [ $a ]
then
   echo "$a : 字符串不为空"
else
   echo "$a : 字符串为空"
fi
```

```shell
abc = efg: a 不等于 b
abc != efg : a 不等于 b
-z abc : 字符串长度不为 0
-n abc : 字符串长度不为 0
abc : 字符串不为空
```

#### 5.6 文件测试运算符

文件测试运算符用于检测 Unix 文件的各种属性。

属性检测描述如下：

| 操作符  | 说明                                                         | 举例                      |
| :------ | :----------------------------------------------------------- | :------------------------ |
| -b file | 检测文件是否是块设备文件，如果是，则返回 true。              | [ -b $file ] 返回 false。 |
| -c file | 检测文件是否是字符设备文件，如果是，则返回 true。            | [ -c $file ] 返回 false。 |
| -d file | 检测文件是否是目录，如果是，则返回 true。                    | [ -d $file ] 返回 false。 |
| -f file | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 | [ -f $file ] 返回 true。  |
| -g file | 检测文件是否设置了 SGID 位，如果是，则返回 true。            | [ -g $file ] 返回 false。 |
| -k file | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。  | [ -k $file ] 返回 false。 |
| -p file | 检测文件是否是有名管道，如果是，则返回 true。                | [ -p $file ] 返回 false。 |
| -u file | 检测文件是否设置了 SUID 位，如果是，则返回 true。            | [ -u $file ] 返回 false。 |
| -r file | 检测文件是否可读，如果是，则返回 true。                      | [ -r $file ] 返回 true。  |
| -w file | 检测文件是否可写，如果是，则返回 true。                      | [ -w $file ] 返回 true。  |
| -x file | 检测文件是否可执行，如果是，则返回 true。                    | [ -x $file ] 返回 true。  |
| -s file | 检测文件是否为空（文件大小是否大于0），不为空返回 true。     | [ -s $file ] 返回 true。  |
| -e file | 检测文件（包括目录）是否存在，如果是，则返回 true。          | [ -e $file ] 返回 true。  |

其他检查符：

- **-S**: 判断某文件是否 socket。
- **-L**: 检测文件是否存在并且是一个符号链接。

实例

变量 file 表示文件 **/var/www/runoob/test.sh**，它的大小为 100 字节，具有 **rwx** 权限。下面的代码，将检测该文件的各种属性：

```shell
#!/bin/bash


file="/var/www/runoob/test.sh"
if [ -r $file ]
then
   echo "文件可读"
else
   echo "文件不可读"
fi
if [ -w $file ]
then
   echo "文件可写"
else
   echo "文件不可写"
fi
if [ -x $file ]
then
   echo "文件可执行"
else
   echo "文件不可执行"
fi
if [ -f $file ]
then
   echo "文件为普通文件"
else
   echo "文件为特殊文件"
fi
if [ -d $file ]
then
   echo "文件是个目录"
else
   echo "文件不是个目录"
fi
if [ -s $file ]
then
   echo "文件不为空"
else
   echo "文件为空"
fi
if [ -e $file ]
then
   echo "文件存在"
else
   echo "文件不存在"
fi
```

执行脚本，输出结果如下所示：

```shell
文件可读
文件可写
文件可执行
文件为普通文件
文件不是个目录
文件不为空
文件存在
```

#### 5.7 自增和自减操作符

尽管 Shell 本身没有像 C、C++ 或 Java 那样的 ++ 和 -- 操作符，但可以通过其他方式实现相同的功能。以下是一些常见的方法：

**使用 let 命令**

**let** 命令允许对整数进行算术运算。

```shell
#!/bin/bash

# 初始化变量
num=5

# 自增
let num++

# 自减
let num--

echo $num
```

**使用 $(( )) 进行算术运算**

**$(( ))** 语法也是进行算术运算的一种方式。

```shell
#!/bin/bash

# 初始化变量
num=5

# 自增
num=$((num + 1))

# 自减
num=$((num - 1))

echo $num
```

**实例**

以下是一个完整的示例脚本，演示了自增和自减操作的使用：

```shell
#!/bin/bash

# 初始化变量
num=5

echo "初始值: $num"

# 自增
let num++
echo "自增后: $num"

# 自减
let num--
echo "自减后: $num"

# 使用 $(( ))
num=$((num + 1))
echo "使用 $(( )) 自增后: $num"

num=$((num - 1))
echo "使用 $(( )) 自减后: $num"

# 使用 expr
num=$(expr $num + 1)
echo "使用 expr 自增后: $num"

num=$(expr $num - 1)
echo "使用 expr 自减后: $num"

# 使用 (( ))
((num++))
echo "使用 (( )) 自增后: $num"

((num--))
echo "使用 (( )) 自减后: $num"
```

运行这个脚本会输出以下内容：

```shell
初始值: 5
自增后: 6
自减后: 5
使用 $(( )) 自增后: 6
使用 $(( )) 自减后: 5
使用 expr 自增后: 6
使用 expr 自减后: 5
使用 (( )) 自增后: 6
使用 (( )) 自减后: 5
```

### 6. Shell echo命令

Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。命令格式：

```shell
echo string
```

您可以使用echo实现更复杂的输出格式控制。

#### 6.1 显示普通字符串

```shell
echo "It is a test"
```

这里的双引号完全可以省略，以下命令与上面实例效果一致：

```shell
echo It is a test
```

#### 6.2 显示转义字符

```shell
echo "\"It is a test\""
```

结果将是:

```shell
"It is a test"
```

同样，双引号也可以省略

#### 6.3 显示变量

read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量

```shell
#!/bin/sh
read name 
echo "$name It is a test"
```

以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:

```shell
[root@www ~]# sh test.sh
OK                     #标准输入
OK It is a test        #输出
```





## Git

### 1. git介绍

#### 1.1 git的三个区域

- 工作区
- 暂存区
- 本地git仓库

在文件夹下的体现如下：

- 工作区：在电脑中能看到的目录
- 暂存区：在.git文件夹内的index中（二进制记录）
- 版本库：指的整个.git文件夹（也认为是本地仓库）

### 2. git配置

安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。因为每一个 Git 提交都会使用这些信息

命令格式如下：中文自己看情况换

- **git config：** 固定命令，设置git相关配置
- **–global：** 全局配置；一次配置，整机在使用git时都生效

```cmd
git config --global user.name 你的用户名  
git config --global user.email 你的邮箱地址  
```

配置成功后可查看是否成功:

```cmd
git config --list  
#如果信息太多，可以输入 q 退出  
```

出现以上内容即为注册成功。如果后续想要修改，只需要重新执行一下命令即可

**文件右侧标记**

右侧没有标记的时候为未修改 或 此文件/文件夹，被git忽略不跟踪变化

M：已修改（Modified） - 文件已被修改但还没有被添加到暂存区

A：已添加（Added） - 文件已经被添加到暂存区，但还没有被提交

D：已删除（Deleted） - 文件已经被删除，并且已经被标记为删除，但还没有提交

R：已重命名（Renamed） - 文件已经被重命名，这也算作是一种修改，需要被添加到暂存区

C：已复制（Copied） - 文件已经被复制，这也算作是一种修改，需要被添加到暂存区

U：已更新但未融合（Updated but Unmerged） - 这表示一个文件已经被更新了，但在合并时发生了冲突，需要手动解决冲突后再标记为已解决

### 3. git基础命令

#### 3.1初始化空的git仓库

​	新建一个文件夹或现有的文件夹并不是 git 仓库，因为文件夹内不包含 `.git` 文件夹，没有被 git 管理可以在新文件夹或现有文件夹，运行如下命令得到 `.git` 文件夹，初始化成功则可让 git 开始准备管理

```cmd
# 初始化 git 仓库, 产物: .git 文件夹 (所在文件夹"内"被管理)  
git init  
```

例如，在新文件夹中输入`git init`命令用于初始化空的git版本库

初始化空的 git 仓库成功后，在项目文件夹中，开启显示隐藏文件，即可查看 `.git` 文件夹

#### 3.2记录更新到git仓库

每当完成了一个阶段的目标，想要记录下它时，就将它提交到仓库

核心操作：`工作区开发`—>`将修改后的文件添加到暂存区`—>`将暂存区的文件记录到版本库`

把工作区变化放到暂存区中，执行如下命令

```cmd
# 将 index.html 添加到暂存区  
git add index.html  
  
# 将css目录下一切添加到暂存区  
git add css  
```

如下命令，可以一次性把所有变化文件放入暂存区

```cmd
# .的意思是当前目录下所有变化都暂存  
git add .  
```

把暂存区内容，提交到版本库，命令如下（此处文字说明可以不加引号）

```cmd
git commit -m '提交的内容说明'  
```

**过程图示：**![Snipaste_2025-04-01_13-54-43](C:\Users\lijialin\Desktop\git\image\Snipaste_2025-04-01_13-54-43.png)

以上命令相当于存档了一次，在版本库中产生一次提交记录并生成版本号

本次存档，不耽误我们在工作区 (项目文件夹) 下继续编写项目

#### 3.3 git日志及状态查看

查看所有提交的日志记录，命令如下

```cmd
git log  
```

当我们的日志越来越多，可能想要简化查看，可以输入如下命令

–oneline：在一行显示简略信息

```cmd
git log --oneline  
```

如果改的代码过多，忘记改过哪些了，可以运行如下命令来查看 git 仓库变化，只能看未提交的所有变更的文件状态

```cmd
git status
```

暂存并再次提交，产生一次版本记录

```cmd
git add .  
git commit -m '新建登录页面_和样式'  
```

#### 3.4版本回退

回退命令语法如下

```cmd
git reset --hard 版本号  
```

查看版本号（每次的版本号随机生成）

```cmd
git log --oneline  
```

尝试回退到 477321b 这次记录上

```cmd
git reset --hard 477321b  
```

如果想要在回到最近一次提交的记录，但发现git log看不到未来的记录了，问题不大。输入`git reflog`命令，可以查看 git 所有的操作记录，包括你的reset记录

```cmd
git reflog 
```

拓展命令：

- git bash（终端）清屏：clear
- git bash（终端）另起一页：Ctrl + L

#### 3.5 git忽略文件

​	有的时候，我们某些文件或文件夹不想让 git 进行跟踪管理。这时候可以在 .git 文件夹同级目录下新增`.gitignore`的忽略文件并写入忽略规则（此处的文件名就是 `.gitignore` ，不是后缀）

项目文件夹结构如下：![Snipaste_2025-04-01_14-20-47](C:\Users\lijialin\Desktop\git\image\Snipaste_2025-04-01_14-20-47.png)

```cmd
# .gitignore内容：  
password.txt  
  
其余用法：  
# 忽略文件夹  
css  
# 忽略文件夹下的某个文件  
css/index.js  
# 忽略文件夹下某类文件  
css/*.js  
```

根目录新建 `password.txt`，查看 git 追踪到了哪些变化

```cmd
git status  
```

发现只新增了`.gitignore` ，符合规则的都被忽略掉了

#### 3.6 创建分支

查看当前版本库所有分支命令如下

```cmd
# 创建分支  
git branch 分支名  
```

手动切换到分支上

```cmd
# 切换分支命令  
git checkout 分支名 
```

第一次创建并切换到 reg 分支，你会发现 master 分支上的所有代码 (和当前节点所有提交记录) 都被复制了过来 了，我们只需要在这个基础上接着往后开发就行

以后在当前 reg 分支下开发，就会在 reg 范围内，每次提交产生一次版本记录，不会影响到别的分支

#### 3.7 分支合并

我们可以把分支里写好的代码，合并到主分支或其他分支上，步骤如下：

首先，切换到你要合并到的目标分支上（以master主分支为例）

```cmd
# 切换分支  
git checkout master  
```

合并命令语法

```cmd
# 把目标分支名下的所有记录, 合并到当前分支下  
git merge 目标分支名  
```

#### 3.8 分支删除

假如注册功能开发完毕，代码已经合并到 master 分支上，我们已经不需要 reg 分支

命令如下

```cmd
git branch -d 分支名  
```

如果分支的修改没有被合并到其他分支上，Git 会提示一个类似以下的错误信息

```cmd
error: The branch 'branch_name' is not fully merged. If you are sure you want to delete it, run 'git branch -D branch_name'.  
```

在这种情况下，Git 建议你确认是否要删除这个分支。如果你确定要删除该分支并且不在乎丢失该分支的修改，你可以使用`git branch -D <branch_name>`命令来强制删除该分支。但请注意，这样会丢失掉分支上的未合并修改

## Hive

### 1. Hive常见数据存储格式（未完全学习）

​	**TextFile:**即正常的文本格式，是Hive默认文件存储格式。存储文件默认每一行就是一条记录，可以指定任意的分隔符进行字段间的分割。但这个格式无压缩，需要的存储空间很大。

​	**RCFile：**是Hadoop中第一个列文件格式。*能够很好的压缩和快速的查询性能。通常写操作比较慢，比非列形式的文件格式需要更多的内存空间和计算量。

### 2. Hive的基本语法

#### 2.1 建表语法

##### 2.1.1 建表格式1：全部使用默认建表方式

```sql
create table students
(
    id bigint,
    name string,
    age int,
    gender string,
    clazz string
)
ROW FORMAT DELIMITED FIELDS TERMINATED BY ','; 
// 必选，指定列分隔符 
​
```

##### 2.1.2  建表格式2：指定location

```sql
create table students2
(
    id bigint,
    name string,
    age int,
    gender string,
    clazz string
)
ROW FORMAT DELIMITED FIELDS TERMINATED BY ','
LOCATION '/input1'; 
// 指定Hive表的数据的存储位置，一般在数据已经上传到HDFS，想要直接使用，会指定Location，
//通常Locaion会跟外部表一起使用，内部表一般使用默认的location
​
```

##### 2.1.3  建表格式3：指定存储格式

```sql
create table students3
(
    id bigint,
    name string,
    age int,
    gender string,
    clazz string
)
ROW FORMAT DELIMITED FIELDS TERMINATED BY ','
STORED AS rcfile; 
// 指定储存格式为rcfile，inputFormat:RCFileInputFormat,outputFormat:RCFileOutputFormat，
//如果不指定，默认为textfile，
//注意：除textfile以外，其他的存储格式的数据都不能直接加载，需要使用从表加载的方式。
​
```

##### 2.1.4  建表格式4：create table xxxx as select_statement(SQL语句)

```sql
create table students4 as select * from students2;
​
```

#### 2.2 Hive加载数据

##### 2.2.1 使用`hdfs dfs -put '本地数据' 'hive表对应的HDFS目录下'`

##### 2.2.2 使用 load data inpath

**从hdfs导入数据，路径可以是目录，会将目录下所有文件导入，但是文件格式必须一致**

```sql
// 将HDFS上的/input1目录下面的数据 移动至 students表对应的HDFS目录下
// 注意是 移动！移动！移动！
load data inpath '/input1/students.txt' into table students;
​
```

```sql
// 清空表
truncate table students;
​
```

**从本地文件系统导入**

```sql
// 加上 local 关键字 可以将Linux本地目录下的文件 上传到 hive表对应HDFS 目录下 原文件不会被删除
load data local inpath '/usr/local/soft/data/students.txt' into table students;
// overwrite 覆盖加载
load data local inpath '/usr/local/soft/data/students.txt' overwrite into table students;
​
```

##### 2.2.3 create table xxx as SQL语句，表对表加载

##### 2.2.4 insert into table xxxx SQL语句 （没有as），表对表加载:

```sql
// 将 students表的数据插入到students2 
//这是复制 不是移动 students表中的表中的数据不会丢失
insert into table students2 select * from students;
​
// 覆盖插入 把into 换成 overwrite
insert overwrite table students2 select * from students;
```

#### 2.3 Hive 内部表（Managed tables）vs 外部表（External tables）

##### **外部表和普通表的区别**

1. 外部表的路径可以自定义，内部表的路径需要在 hive/warehouse/目录下
2. 删除表后，普通表数据文件和表信息都删除。外部表仅删除表信息

##### 2.3.1 建表语句：

```sql
// 内部表
create table students_internal
(
    id bigint,
    name string,
    age int,
    gender string,
    clazz string
)
ROW FORMAT DELIMITED FIELDS TERMINATED BY ','
LOCATION '/input2';
​
// 外部表
create external table students_external
(
    id bigint,
    name string,
    age int,
    gender string,
    clazz string
)
ROW FORMAT DELIMITED FIELDS TERMINATED BY ','
LOCATION '/input3';
​
```

##### 2.3.2 加载数据：

```cmd
hive> dfs -put /usr/local/soft/data/students.txt /input2/;
hive> dfs -put /usr/local/soft/data/students.txt /input3/;
​
```

##### 2.3.3删除表：

```cmd
hive> drop table students_internal;
Moved: 'hdfs://master:9000/input2' to trash at: hdfs://master:9000/user/root/.Trash/Current
OK
Time taken: 0.474 seconds
hive> drop table students_external;
OK
Time taken: 0.09 seconds
​
```

1、可以看出，删除内部表的时候，表中的数据（HDFS上的文件）会被同表的元数据一起删除；删除外部表的时候，只会删除表的元数据，而不会删除表中的数据（HDFS上的文件）
2、一般在公司中，使用外部表多一点，因为数据可以需要被多个程序使用，避免误删，通常外部表会结合location一起使用
3、外部表还可以将其他数据源中的数据 映射到 hive中，比如说：hbase，ElasticSearch…
4、设计外部表的初衷就是 让 表的元数据 与 数据 解耦

#### 2.4 Hive分区：

​	分区表实际上是在表的目录下再以分区命名，建子目录；

​	作用：进行分区裁剪，避免全表扫描，减少MapReduce处理的数据量，提高效率

一般在公司的hive中，所有的表基本上都是分区表，通常按日期分区、地域分区；分区表在使用的时候记得加上分区字段；分区也不是越多越好，一般不超过3级，根据实际业务衡量

分区的概念和分区表：
	分区表指的是在创建表时指定分区空间，实际上就是在hdfs上表的目录下再创建子目录。
	在使用数据时如果指定了需要访问的分区名称，则只会读取相应的分区，避免全表扫描，提高查询效率。

##### 2.4.1 建立分区表：

```sql
create external table students_pt1
(
    id bigint,
    name string,
    age int,
    gender string,
    clazz string
)
PARTITIONED BY(pt string)
ROW FORMAT DELIMITED FIELDS TERMINATED BY ',';
​
```

##### 2.4.2 增加一个分区：

```sql
alter table students_pt1 add partition(pt='20210904');
```

##### 2.4.3 删除一个分区：

```sql
alter table students_pt drop partition(pt='20210904');
​
```

##### 2.4.4 查看某个表的所有分区：

```sql
 // 推荐这种方式（直接从元数据中获取分区信息）
show partitions students_pt;
​
// 不推荐
select distinct pt from students_pt; 
​
```

#### 2.5 Hive动态分区

有的时候我们原始表中的数据里面包含了 ‘‘日期字段 dt’’，我们需要根据dt中不同的日期，分为不同的分区，将原始表改造成分区表。

<font size=3 color="red">hive默认不开启动态分区</font>

`动态分区`：**根据数据中某几列的不同的取值 划分 不同的分区**

```cmd
# 表示开启动态分区
hive> set hive.exec.dynamic.partition=true;
​
# 表示动态分区模式：strict（需要配合静态分区一起使用）、nostrict
​
# strict： insert into table students_pt partition(dt='anhui',pt) select ......,pt from students;
hive> set hive.exec.dynamic.partition.mode=nostrict;
​
# 表示支持的最大的分区数量为1000，可以根据业务自己调整
hive> set hive.exec.max.dynamic.partitions.pernode=1000;
```

##### 2.5.1 建立原始表并加载数据

```sql
create table students_dt
(
    id bigint,
    name string,
    age int,
    gender string,
    clazz string,
    dt string
)
ROW FORMAT DELIMITED FIELDS TERMINATED BY ',';
```

##### 2.5.2 建立分区表并加载数据

```sql
create table students_dt_p
(
    id bigint,
    name string,
    age int,
    gender string,
    clazz string
)
PARTITIONED BY(dt string)
ROW FORMAT DELIMITED FIELDS TERMINATED BY ',';
```

##### 2.5.3 使用动态分区插入数据

```sql
// 分区字段需要放在 select 的最后，如果有多个分区字段 同理，
//它是按位置匹配，不是按名字匹配
insert into table students_dt_p partition(dt) select id,name,age,gender,clazz,dt from students_dt;
​
// 比如下面这条语句会使用age作为分区字段，而不会使用student_dt中的dt作为分区字段
insert into table students_dt_p partition(dt) select id,name,age,gender,dt,age from students_dt;
​
```

##### 2.5.4 多级分区

```sql
create table students_year_month
(
    id bigint,
    name string,
    age int,
    gender string,
    clazz string,
    year string,
    month string
)
ROW FORMAT DELIMITED FIELDS TERMINATED BY ',';
​
create table students_year_month_pt
(
    id bigint,
    name string,
    age int,
    gender string,
    clazz string
)
PARTITIONED BY(year string,month string)
ROW FORMAT DELIMITED FIELDS TERMINATED BY ',';
​
insert into table students_year_month_pt partition(year,month) select id,name,age,gender,clazz,year,month from students_year_month;
​
```

#### 2.6 Hive分桶

```
分桶实际上是对文件（数据）的进一步切分；Hive默认关闭分桶；分桶的作用：在往分桶表中插入数据的时候，会根据 clustered by 指定的字段 进行hash分组 对指定的buckets个数 进行取余，进而可以将数据分割成buckets个数个文件，以达到数据均匀分布，可以解决Map端的“数据倾斜”问题，方便我们取抽样数据，提高Map join效率；分桶字段 需要根据业务进行设定
```

##### 2.6.1 开启分桶开关

```sql
hive> set hive.enforce.bucketing=true;
```

##### 2.6.2 建立分桶表

```sql
create table students_buks
(
    id bigint,
    name string,
    age int,
    gender string,
    clazz string
)
CLUSTERED BY (clazz) into 12 BUCKETS
ROW FORMAT DELIMITED FIELDS TERMINATED BY ','; 
```

##### 2.6.3 往分桶表中插入数据

```sql
// 直接使用load data 并不能将数据打散
load data local inpath '/usr/local/soft/data/students.txt' into table students_buks;
​
// 需要使用下面这种方式插入数据，才能使分桶表真正发挥作用
insert into students_buks select * from students;
​
```

##### 2.7 Hive连接JDBC（未学习）

### 3 Hive的数据类型

#### 3.1 基本数据类型

##### 3.1.1 数据型：

```sql
TINYINT — 微整型，只占用1个字节，只能存储0-255的整数。
SMALLINT– 小整型，占用2个字节，存储范围–32768 到 32767。
INT– 整型，占用4个字节，存储范围-2147483648到2147483647。
BIGINT– 长整型，占用8个字节，存储范围-2^63到2^63-1。
```

##### 3.1.2 布尔型：

```sql
BOOLEAN — TRUE/FALSE
```

##### 3.1.3 浮点型：

```sql
FLOAT– 单精度浮点数。
DOUBLE– 双精度浮点数。
```

##### 3.1.4 字符串型：

```sql
STRING– 不设定长度。
```

#### 3.2 日期类型

**时间戳 timestamp**

**日期 date**

```sql
create table testDate(
    ts timestamp
    ,dt date
) row format delimited fields terminated by ',';
​
// 2021-01-14 14:24:57.200,2021-01-11
```

**时间戳与时间字符串转换**

```sql
// from_unixtime 传入一个时间戳以及pattern（yyyy-MM-dd） 
//可以将 时间戳转换成对应格式的字符串
select from_unixtime(1630915221,'yyyy年MM月dd日 HH时mm分ss秒')
​
// unix_timestamp 传入一个时间字符串以及pattern，
//可以将字符串按照pattern转换成时间戳
select unix_timestamp('2021年09月07日 11时00分21秒','yyyy年MM月dd日 HH时mm分ss秒');
select unix_timestamp('2021-01-14 14:24:57.200')
```

#### 3.3 复杂数据类型

**Structs**

**Maps**

**Arrays**

[复杂数据类型相关链接](https://blog.csdn.net/woshixuye/article/details/53317009)

### 4. Hive HQL使用语法

```sql
我们知道SQL语言可以分为5大类：
(1）DDL(Data Definition Language) 数据定义语言
用来定义数据库对象：数据库，表，列等。
关键字：create，drap,alter等
( 2）DML(Data Manipulation Language) 数据操作语言
用来对数据库中表的数据进行增删改。
关键字：insert,delete,update等
( 3）DQL(Data Query Language)数据查询语言
用来查询数据库表的记录（数据）。
关键字：select,where 等
( 4）DCL(Data Control Language) 数据控制语言
用来定义数据库的访问权限和安全级别，及创建用户。
关键字：GRANT，REVOKE等
(5)TCL(Transaction Control Language) 事务控制语言
T CL经常被用于快速原型开发、脚本编程、GUI和测试等方面，
关键字: commit、rollback等。
```

#### 4.1 HQL语法-DDL

```sql
创建数据库 create database xxxxx;
查看数据库 show databases；
删除数据库 drop database tmp;
强制删除数据库：drop database tmp cascade;
查看表：SHOW TABLES；
查看表的元信息：
    desc test_table;
    describe extended test_table;
    describe formatted test_table;
查看建表语句：show create table table_XXX
重命名表：
    alter table test_table rename to new_table;
修改列数据类型：alter table lv_test change column colxx string;
增加、删除分区：
    alter table test_table add partition (pt=xxxx) 
    alter table test_table drop if exists partition(...);
```

#### 4.2 HQL语法-DML

```sql
where  用于过滤，分区裁剪，指定条件
​
join  用于两表关联，left outer join ，join，mapjoin（1.2版本后默认开启）
​
group by  用于分组聚合，通常结合聚合函数一起使用
​
order by  用于全局排序，要尽量避免排序，是针对全局排序的，即对所有的reduce输出是有序的
​
sort by  :当有多个reduce时，只能保证单个reduce输出有序，不能保证全局有序
​
cluster by = distribute by + sort by
​
distinct 去重
​
inner join 返回两张表中交集的部分
​
DESCRIBE 数据库表名  列出数据库的所有列
```

[order by、distribute by、sort by、cluster by详解](https://zhuanlan.zhihu.com/p/93747613)

### 5. Hive HQL使用注意

```html
count(*)、count(1) 、count(‘字段名’) 的区别
​
HQL 执行优先级：
from、where、 group by 、having、order by、join、select 、limit
​
where 条件里不支持不等式子查询，实际上是支持 in、not in、exists、not exists
​
hive中大小写不敏感
​
在hive中，数据中如果有null字符串，加载到表中的时候会变成 null （不是字符串）
如果需要判断 null，使用 某个字段名 is null 这样的方式来判断;或者使用 nvl() 函数，不能 直接 某个字段名 == null
​
使用explain查看SQL执行计划
```

### 6. Hive的函数使用

#### 6.1 Hive常用函数

##### 6.1.1关系运算符

```sql
// 等值比较 = == <=>
// 不等值比较 != <>
// 区间比较： select * from default.students where id between 1500100001 and 1500100010;
// 空值/非空值判断：is null、is not null、nvl()、isnull()
// like、rlike、regexp用法
```

[Hive中rlike,like,not like，regexp区别与使用详解](https://blog.csdn.net/qq_26442553/article/details/79452221)

##### 6.1.2 数值计算

```sql
取整函数(四舍五入)：round
向上取整：ceil
向下取整：floor
```

##### 6.1.3 条件函数

**if： if(表达式,如果表达式成立的返回值,如果表达式不成立的返回值)**

```sql
select if(1>0,1,0); 
select if(1>0,if(-1>0,-1,1),0);
```

**COALESCE**

```sql
select COALESCE(null,'1','2'); // 1 从左往右 一次匹配 直到非空为止
select COALESCE('1',null,'2'); // 1
```

**case when … then … else … end**

```sql
select  score
        ,case when score>120 then '优秀'
              when score>100 then '良好'
              when score>90 then '及格'
        else '不及格'
        end as pingfen
from default.score limit 20;
​
#  注意条件的顺序
```

##### 6.1.4 日期函数

```sql
select from_unixtime(1610611142,'YYYY/MM/dd HH:mm:ss');
​
select from_unixtime(unix_timestamp(),'YYYY/MM/dd HH:mm:ss');
​
// '2021年01月14日' -> '2021-01-14'
select from_unixtime(unix_timestamp('2021年01月14日','yyyy年MM月dd日'),'yyyy-MM-dd');
// "04牛2021数加16逼" -> "2021/04/16"
select from_unixtime(unix_timestamp("04牛2021数加16逼","MM牛yyyy数加dd逼"),"yyyy/MM/dd");
​
```

##### 6.1.5 字符串函数

```sql
concat('123','456'); // 123456
concat('123','456',null); // NULL
​
select concat_ws('#','a','b','c'); // a#b#c
select concat_ws('#','a','b','c',NULL); // a#b#c 可以指定分隔符，并且会自动忽略NULL
select concat_ws("|",cast(id as string),name,cast(age as string),gender,clazz) from students limit 10;
​
select substring("abcdefg",1); // abcdefg HQL中涉及到位置的时候 是从1开始计数
// '2021/01/14' -> '2021-01-14'
select concat_ws("-",substring('2021/01/14',1,4),substring('2021/01/14',6,2),substring('2021/01/14',9,2));
​
select split("abcde,fgh",","); // ["abcde","fgh"]
select split("a,b,c,d,e,f",",")[2]; // c
​
select explode(split("abcde,fgh",",")); // abcde
                                        //  fgh
​
// 解析json格式的数据
select get_json_object('{"name":"zhangsan","age":18,"score":[{"course_name":"math","score":100},{"course_name":"english","score":60}]}',"$.score[0].score"); // 100
```

#### 6.2 Hive高级函数

##### 6.2.1 窗口函数（开窗函数）：用户分组中开窗

​	在sql中有一类函数叫做聚合函数,例如sum()、avg()、max()等等,这类函数可以将多行数据按照规则聚集为一行,一般来讲聚集后的行数是要少于聚集前的行数的.但是有时我们想要既显示聚集前的数据,又要显示聚集后的数据,这时我们便引入了窗口函数。（开创函数，我们一般用于分组中求 TopN问题）
[Hive窗口函数](https://blog.csdn.net/qq_26937525/article/details/54925827)

**样例演示**

```sql
数据：
111,69,class1,department1
112,80,class1,department1
113,74,class1,department1
114,94,class1,department1
115,93,class1,department1
121,74,class2,department1
122,86,class2,department1
123,78,class2,department1
124,70,class2,department1
211,93,class1,department2
212,83,class1,department2
213,94,class1,department2
214,94,class1,department2
215,82,class1,department2
216,74,class1,department2
221,99,class2,department2
222,78,class2,department2
223,74,class2,department2
224,80,class2,department2
225,85,class2,department2
​
建表：
create table new_score(
    id  int
    ,score int
    ,clazz string
    ,department string
) row format delimited fields terminated by ",";
```

**row_number()：无并列排名**

```sql
使用格式：
 select xxxx, row_number() over(partition by 分组字段 order by 排序字段 desc) as rn from tb group by xxxx
```

**dense_rank()：有并列排名，并且依次递增**

**rank()：有并列排名，不依次递增**

**percent_rank()：(rank的结果-1)/(分区内数据的个数-1)**

**cume_dist()：计算某个窗口或分区中某个值的累积分布。**

**假定升序排序，则使用以下公式确定累积分布： 小于等于当前值x的行数 / 窗口或partition分区内的总行数。其中，x 等于 order by 子句中指定的列的当前行中的值。**

## 实习

### 1. CRM 

Customer Relationship Management

中文：客户关系管理系统

核心用途：用于**管理客户信息**、**追踪销售过程**、**维护客户关系**、提升客户满意度和销售转化率。

主要功能模块：

| 模块     | 功能说明                                     |
| -------- | -------------------------------------------- |
| 客户管理 | 存储客户资料、联系方式、跟进记录等           |
| 销售管理 | 跟踪销售机会、记录销售流程、分析销售业绩     |
| 市场营销 | 客户分类、群发短信邮件、活动管理、营销自动化 |
| 服务支持 | 客户投诉、售后服务、客户满意度调查           |
| 分析报表 | 客户画像、销售漏斗、业绩统计等               |

使用对象：销售人员、市场人员、客服人员、管理层

### 2. ERP

Enterprise Resource Planning

中文：企业资源计划系统

核心用途：全面管理企业的“人、财、物”，对采购、生产、库存、财务、销售等进行系统化整合，是企业运作的中枢系统。

主要功能模块：

| 模块     | 功能说明                                   |
| -------- | ------------------------------------------ |
| 财务管理 | 会计、报销、应收应付、资产管理             |
| 采购管理 | 采购申请、订单、收货、供应商管理           |
| 库存管理 | 仓库、物料、出入库、库存预警               |
| 销售管理 | 报价、订单、发货、回款                     |
| 生产管理 | 生产计划、工序管理、成本核算               |
| 人力资源 | 员工档案、工资、考勤（有时会拆分为HR系统） |

使用对象：企业管理层、财务人员、采购/销售/仓储/物流部门等

PS：鼎捷

### 3. OA 

Office Automation

中文：办公自动化系统

核心用途：提升企业内部办公效率，实现**日常事务的电子化和流程自动化**，如请假、报销、文件审批等。

主要功能模块：

| 模块     | 功能说明                             |
| -------- | ------------------------------------ |
| 流程审批 | 请假、报销、采购申请、合同审批等流程 |
| 日程管理 | 日历、会议安排、提醒等               |
| 通知公告 | 企业内部通知、公告、新闻             |
| 公文管理 | 发文收文、文档流转                   |
| 协同办公 | 邮件、即时通讯、任务分配、共享文件   |

 使用对象：全体员工、行政、人事、领导层
